#!/usr/bin/env python3

"""
Script to run through WASS input raw images (converted to TIF format)
and check for inconsistencies such as un-synced image pairs or missing
frames. The script moves detected un-synced images to a new directory in
the WASS input folder called "unsynced". If the directory does not exist
it will be generated by the script.
"""

import os, glob, sys
import shutil
from tqdm import tqdm
import numpy as np
from datetime import datetime as DT
from argparse import ArgumentParser
from sw_pyfuns.wass_stuff import wass_load as wlo

# Input arguments
def parse_args(**kwargs):
    parser = ArgumentParser()
    parser.add_argument("-dr", 
            help=("Path to data_root (work) directory"),
            type=str,
            default='/home/mikapm/wass/test/20210305_1200_input',
            )
    parser.add_argument("-type", 
            help=("Image format (file extension)"),
            type=str,
            choices=['tif', 'png', 'jpg'],
            default='tif',
            )
    parser.add_argument("--wass_ds", 
            help=("WASS directory structure?"),
            action="store_true",
            )
    return parser.parse_args(**kwargs)

# Call args parser to create variables out of input arguments
args = parse_args(args=sys.argv[1:])

# Define directory for unmatched frames
unmatch_dir = os.path.join(args.dr, 'unmatched')

# Define image directory path
if args.wass_ds:
    # Construct WASS load object
    WL = wlo.WASS_load(args.dr)
    imdir = os.path.join(WL.data_root, 'input')
else:
    # Get cam0 and cam1 files directly from data root directory
    imdir = args.dr

# List all image filenames
cam0 = sorted(glob.iglob(os.path.join(imdir, 'cam0', '*.tif')))
cam1 = sorted(glob.iglob(os.path.join(imdir, 'cam1', '*.tif')))

# Look for matching image pairs
print('Looking for matches ... ')
for im_l, im_r in tqdm(zip(cam0, cam1)):
    # Get left filename without extension
    fn_root_l = os.path.split(os.path.splitext(im_l)[0])[1]
    # Check if the timestamp matches any in cam1 folder
    if not any(fn_root_l.split('_')[1] in s for s in cam1):
        # No match -> move file to unmatched folder
        if not os.path.isdir(unmatch_dir):
            # Make directory
            print('Making unmatched directory ... ')
            os.mkdir(unmatch_dir)
        # Move file
        print('Moving file {} to unmatched ...'.format(im_l))
        shutil.move(im_l, unmatch_dir)
    # Get right filename without extension
    fn_root_r = os.path.split(os.path.splitext(im_r)[0])[1]
    # Check for matching filenames in cam0 dir
    if not any(fn_root_r.split('_')[1] in s for s in cam0):
        # No match -> move file to unmatched folder
        if not os.path.isdir(unmatch_dir):
            # Make directory
            print('Making unmatched directory ... ')
            os.mkdir(unmatch_dir)
        # Move file
        print('Moving file {} to unmatched ...'.format(im_r))
        shutil.move(im_r, unmatch_dir)

# Get new cam0 and cam1 directory contents
cam0_new = sorted(glob.iglob(os.path.join(imdir, 'cam0', '*.tif')))
cam1_new = sorted(glob.iglob(os.path.join(imdir, 'cam1', '*.tif')))
# Correct order numbers of matched frames
if not len(cam0_new) == len(cam1_new):
    raise ValueError('Unequal numbers of left and right frames.')
else:
    print('Renaming files ... ')
    for i, (im_l, im_r) in tqdm(enumerate(zip(cam0_new, cam1_new))):
        # Make new order numbers for left and right frames
        on_l_old = os.path.split(os.path.splitext(im_l)[0])[1].split('_')[0]
        on_r_old = os.path.split(os.path.splitext(im_r)[0])[1].split('_')[0]
        on_l_new = '{:06d}'.format(i)
        on_r_new = '{:06d}'.format(i)
        # Define new filenames with correct order numbers
        im_l_new = im_l.replace(on_l_old, on_l_new)
        im_r_new = im_r.replace(on_r_old, on_r_new)
        # Rename files
        os.rename(im_l, im_l_new)
        os.rename(im_r, im_r_new)


